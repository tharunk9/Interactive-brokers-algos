# -*- coding: utf-8 -*-
"""
Created on Sun May  16 21:05:45 2022

@author: Tharun

S&P500 MACD, stochastic, ATR for stoploss strategy

"""


# Import libraries
from ibapi.client import EClient
from ibapi.wrapper import EWrapper
from ibapi.contract import Contract
from ibapi.order import Order
import pandas as pd
import threading
import time
import talib as ta

class TradeApp(EWrapper, EClient): 
    def __init__(self): 
        EClient.__init__(self, self) 
        self.data = {}
        self.pos_df = pd.DataFrame(columns=['Account', 'Symbol', 'SecType',
                                    'Currency', 'Position', 'Avg cost'])
        self.order_df = pd.DataFrame(columns=['PermId', 'ClientId', 'OrderId',
                                          'Account', 'Symbol', 'SecType',
                                          'Exchange', 'Action', 'OrderType',
                                          'TotalQty', 'CashQty', 'LmtPrice',
                                          'AuxPrice', 'Status'])
        
    def historicalData(self, reqId, bar):
        #print(f'Time: {bar.date}, Open: {bar.open}, Close: {bar.close}')
        if reqId not in self.data:
            self.data[reqId] = [{"Date":bar.date,"Open":bar.open,"High":bar.high,"Low":bar.low,"Close":bar.close,"Volume":bar.volume}]
        else:
            self.data[reqId].append({"Date":bar.date,"Open":bar.open,"High":bar.high,"Low":bar.low,"Close":bar.close,"Volume":bar.volume})

    def nextValidId(self, orderId):
        super().nextValidId(orderId)
        self.nextValidOrderId = orderId
        print("NextValidId:", orderId)
        
    def position(self, account, contract, position, avgCost):
        super().position(account, contract, position, avgCost)
        dictionary = {"Account":account, "Symbol": contract.symbol, "SecType": contract.secType,
                      "Currency": contract.currency, "Position": position, "Avg cost": avgCost}
        self.pos_df = self.pos_df.append(dictionary, ignore_index=True)
        
    def positionEnd(self):
        print("Latest position data extracted")
        
    def openOrder(self, orderId, contract, order, orderState):
        super().openOrder(orderId, contract, order, orderState)
        dictionary = {"PermId":order.permId, "ClientId": order.clientId, "OrderId": orderId, 
                      "Account": order.account, "Symbol": contract.symbol, "SecType": contract.secType,
                      "Exchange": contract.exchange, "Action": order.action, "OrderType": order.orderType,
                      "TotalQty": order.totalQuantity, "CashQty": order.cashQty, 
                      "LmtPrice": order.lmtPrice, "AuxPrice": order.auxPrice, "Status": orderState.status}
        self.order_df = self.order_df.append(dictionary, ignore_index=True)
        



def snp_futures(symbol, exp_date = "202206", sec_type="FUT",currency="USD",exchange="GLOBEX"):
    contract = Contract()
    contract.symbol = symbol
    contract.secType = sec_type
    contract.currency = currency
    contract.exchange = exchange
    contract.lastTradeDateOrContractMonth = exp_date
    return contract



def histData(req_num,contract,duration,candle_size):
    """extracts historical data"""
    app.reqHistoricalData(reqId=req_num, 
                          contract=contract,
                          endDateTime='',
                          durationStr=duration,
                          barSizeSetting=candle_size,
                          whatToShow='ADJUSTED_LAST',
                          useRTH=0,
                          formatDate=1,
                          keepUpToDate=0,
                          chartOptions=[])	 # EClient function to request contract details


def websocket_con():
    app.run()

app = TradeApp()
app.connect(host='127.0.0.1', port=7496, clientId=23) #port 4002 for ib gateway paper trading/7497 for TWS paper trading/ 7496 for live trading
con_thread = threading.Thread(target=websocket_con, daemon=True)
con_thread.start()

tickers = ["MES"]


capital = 10000
###################storing trade app object in dataframe#######################
def dataDataframe(TradeApp_obj,symbols, symbol):
    "returns extracted historical data in dataframe format"
    df = pd.DataFrame(TradeApp_obj.data[symbols.index(symbol)])
    df.set_index("Date",inplace=True)
    return df

def MACD(DF,a=12,b=26,c=9):
    """function to calculate MACD"""
    
    df = DF.copy()
    df["MACD"], df["Signal"], df["macd_hist"] = ta.MACD(df['Close'], fastperiod= a, slowperiod= b, signalperiod= 9)
    df.dropna(inplace=True)
    
    return df

def stochOscltr(DF,a=20,b=3):
    """function to calculate Stochastics
       a = lookback period
       b = moving average window for %D"""
       
    df = DF.copy()
    df['C-L'] = df['Close'] - df['Low'].rolling(a).min()
    df['H-L'] = df['High'].rolling(a).max() - df['Low'].rolling(a).min()
    df['%K'] = df['C-L']/df['H-L']*100
    #df['%D'] = df['%K'].ewm(span=b,min_periods=b).mean()
    return df['%K'].rolling(b).mean()

def atr(DF,n):
    "function to calculate True Range and Average True Range"
    df = DF.copy()
    tp_atr = ta.ATR(df['High'], df["Low"], df["Close"], timeperiod= n)
    df["ATR"]  = round(tp_atr)+ 0.5
    return df['ATR']



def marketOrder(direction,quantity):
    order = Order()
    order.action = direction
    order.orderType = "MKT"
    order.totalQuantity = quantity
    order.tif = "IOC"
    order.eTradeOnly = False
    order.firmQuoteOnly = False
    return order

def stopOrder(direction,quantity,st_price):
    order = Order()
    order.action = direction
    order.orderType = "STP"
    order.totalQuantity = quantity
    order.auxPrice = st_price
    return order



def buy_cond1(DF):
    df = DF.copy()
    if df["macd"][-1] > df["signal"][-1] and \
        df["stoch"][-1] > 30 and \
        df["stoch"][-1] > df["stoch"][-2]:
        cond1 = 1
    else: 
        cond1 = 0
    return cond1
    
    
    
    
def sell_cond1():
    pos_df = app.pos_df
    time.sleep(5) 
    sl_q = pos_df[pos_df["Symbol"]==ticker]["Position"].sort_values(ascending=True).values[-1]
    app.placeOrder(order_id+1, snp_futures(ticker), stopOrder("SELL",sl_q, df["Close"][-1] - df["atr"][-1]))
    return

def buy_man():
    app.reqIds(-1)
    time.sleep(2)
    
    order_id = app.nextValidOrderId
    app.placeOrder(order_id,snp_futures(ticker),marketOrder("BUY",quantity))
    time.sleep(5)
    return

def main():
    app.data = {}
    app.pos_df = pd.DataFrame(columns=['Account', 'Symbol', 'SecType',
                            'Currency', 'Position', 'Avg cost'])
    app.order_df = pd.DataFrame(columns=['PermId', 'ClientId', 'OrderId',
                                      'Account', 'Symbol', 'SecType',
                                      'Exchange', 'Action', 'OrderType',
                                      'TotalQty', 'CashQty', 'LmtPrice',
                                      'AuxPrice', 'Status'])
    app.reqPositions()
    time.sleep(2)
    
    pos_df = app.pos_df
    pos_df.drop_duplicates(inplace=True,ignore_index=True) # position callback tends to give duplicate values
    app.reqOpenOrders()
    time.sleep(2)
    
    ord_df = app.order_df
    


    for ticker in tickers:
        
        print("starting passthrough for.....",ticker)
        histData(tickers.index(ticker),snp_futures(ticker),'20 D', '5 mins')
        time.sleep(3)
        
        df = dataDataframe(app,tickers,ticker)
        df["stoch"] = stochOscltr(df)
        df["macd"] = MACD(df)["MACD"]
        df["signal"] = MACD(df)["Signal"]
        df["atr"] = atr(df,60)
        df.dropna(inplace=True)
        
        # quantity = int(capital/df["Close"][-1])
        quantity = 2
        
        if quantity == 0:
            continue
        
        if len(pos_df.columns)==0:
            
            if buy_cond1(df):
                   buy_man()
                   
                   try:            
                       sell_cond1()
                       
                   except Exception as e:
                        print(e, "no fill for {}".format(ticker))
          
        elif len(pos_df.columns)!=0 and ticker not in pos_df["Symbol"].tolist():
            
            if buy_cond1(df):
                   buy_man()           
                   
                   try:                      
                       sell_cond1()
                       
                   except Exception as e:
                        print(e, "no fill for {}".format(ticker))
                        
                        
                                        
                    
                   
        elif len(pos_df.columns)!=0 and ticker in pos_df["Symbol"].tolist():
            
            if pos_df[pos_df["Symbol"]==ticker]["Position"].sort_values(ascending=True).values[-1] == 0:
                
                if buy_cond1(df):
                   buy_man()
                                      
                   try:
                       sell_cond1()         
                       
                   except Exception as e:
                        print(e, "no fill for {}".format(ticker))
                        
                        
            elif pos_df[pos_df["Symbol"] == ticker]["Position"].sort_values(ascending = True).values[-1] > 0:
                try:
                    ord_id = ord_df[ord_df["Symbol"]==ticker]["OrderId"].sort_values(ascending=True).values[-1]
                    old_quantity = pos_df[pos_df["Symbol"]==ticker]["Position"].sort_values(ascending=True).values[-1]
                    app.cancelOrder(ord_id)
                    app.reqIds(-1)
                    time.sleep(2)
                    order_id = app.nextValidOrderId
                    app.placeOrder(order_id,snp_futures(ticker),stopOrder("SELL",old_quantity, df["Close"][-1] - df["atr"][-1]))
                    
                except Exception as e:
                    print(ticker,e)


#extract and store historical data in dataframe repetitively
starttime = time.time()
timeout = time.time() + 60*60*23

while time.time() <= timeout:
    main()
    time.sleep(300 - ((time.time() - starttime) % 300.0))
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
